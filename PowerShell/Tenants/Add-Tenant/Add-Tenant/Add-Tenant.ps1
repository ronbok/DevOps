<# 
.SYNOPSIS 
    This PowerShell script is intended to be executed remotely to create a new Steward AppSuite Tenant using an
	Azure AD credential with proper RBAC permissions to create such a group.  This PowerShell Script makes it easier
    to create an Steward AppSuite Tenant instead of using the Management Portal interactively.
.DESCRIPTION 
    This adds one Steward AppSuite Tenant to the Tenant Manifest.  It also creates a new Resource Group for the Tenant in the form
    AzureRGEnvironmentName_AzureRGTenantName where valid values for AzureRGEnvironmentName = "Development", "Test", "Stage", "Production",
    "Subscription" and valid AzureRGTenantName values are "Common" or a specific tenant name like "StewardHealthcare" or
    "BlueMetalHealthcare".

    Additionally, Resource Group tags are created/assigned for "Environment" and "Tenant" with the same values defined for
	AzureRGEnvironmentName and AzureRGTenantName for each Resource Group created.  Some Resource like Azure Sql Database are assigned
    an additional tag called TenantKey using the unique key generated by this script.

    If a real Production environment for a specific Saa tenant is desired, specify "Production" for the AzureRGEnvironmentName
	(Environment type) and "TenantName" for AzureRGTenantName (Tenant).

.NOTES 
    File Name  : Add-Tenant.ps1
               :
    Author     : Ron Bokleman - ron.bokleman@bluemetal.com
               :
    Requires   : PowerShell V5 or above, PowerShell / ISE Elevated, Microsoft Azure PowerShell v1.4.0 May 2016
			   : from the Web Platform Installer.
               :
    Requires   : Azure Subscription needs to be setup in advance and you must know the name.
			   : The executor will be prompted for valid OrgID/MicrosoftID credentials.
               : User must have sufficient privledges to create a new Resource Group within the specified subscription.
               :
    Optional   : This can be called from a .bat file as desired to add a new Steward AppSuite Tenant.
			   : An example is included which demonstrates how to provide input for creating a new Steward AppSuite Tenant.
               :
    Created    : 03/08/2016
	Updated	   : 03/16/2016 v1.0
	Updated    : 03/23/2016 v1.1 Bug fixes for truncating the tenant manifest table name incorreclty.
    Updated    : 04/14/2016 v1.2 Significant changes made to support a new tenant manifest schema.
    Updated    : 05/10/2016 v1.2 Updated to support tenant manifest sql database (MDS, RM, DM) connection string changes.
    Updated    : 05/13/2016 v1.3 Crtical update to fix PowerShell v1.4.0 breaking changes to Get-AzureRmStorageAccountKey.
    Updated    : 05/13/2016 v1.3 Updated to support tenant manifest sql database (MDS, RM, DM, SSAS) connection string changes.
	Updated    : 06/14/2016 v1.4 Updated to remove Azure SQL Database passwords from Tenant Manifest.
	Updated    : 06/14/2016 v1.4 Added new code to create and store a tenant specific encryption key in the Key Vault specified
							     for use by the AppSuiteIngestionAPI[Environment].
    Updated    : 06/20/2016 v1.5 Changed the method to create and store the tenant specific encryption key in the Key Vault.
    Updated    : 06/24/2016 v1.6 Added Service Bus .dll in order to provision required tenant queues.
	Updated    : 07/12/2016 v1.7 Added new code to store the tenant specific storage account access key in the Key Vault specified.

    Please do not forget to ensure you have the proper local PowerShell Execution Policy set:

        Example:  Set-ExecutionPolicy Unrestricted 

    NEED HELP?

    Get-Help ./Add-Tenant.ps1 [Null], [-Full], [-Detailed], [-Examples]

.LINK
    Additional Information:
    
    https://msdn.microsoft.com/en-us/library/mt125356.aspx
    
    Connect with Me: 
    
    http://ronbokleman.wordpress.com
    http://www.linkedin.com/pub/ron-bokleman/1/14b/200

.PARAMETER Subscription
    Example:  Subcription Name i.e. "AppSuite"
.PARAMETER AzureRegion
    Example:  "East US 2"
.PARAMETER AzureRGName
    Example: "Subscription_Common"
.PARAMETER AzureSAName
    Example: "sassubcom1"
.PARAMETER TableName
    Example: "TMDevelopment"
.PARAMETER KVName
    Example: "ssasdcs"
.PARAMETER TenantName
    Example: "StewardHealthcare"
.PARAMETER TenantDomain
    Example: "steward.org"
.PARAMETER DBServer
    Example: "sasdevelopment1"
.PARAMETER SSASServer1
    Example "sass-dev01"
.PARAMETER SSASServer2
    Example:"sass-dev02"
.PARAMETER Active
    Example: "Y" or "N"
.EXAMPLE
    ./Add-Tenant.ps1 -Subscription "AppSuite" -AzureRegion "East US 2" -AzureRGName "Subscription_Common" -AzureSAName "sassubcom1" -TableName "TMDevelopment" -KVName "sasdcs" -TenantName "StewardHealthcare" -TenantDomain "steward.org" -DBServer "sasdevelopment1" -SSASServer1 "ssas-dev1" -SSASServer2 "ssas-dev2" -Active "Y" -Verbose
.EXAMPLE
    ./Add-Tenant.ps1 "AppSuite" "East US 2" "Subscription_Common" "sassubcom1" "TMDevelopment" "sasdcs" "StewardHealthcare" "steward.org" "sasdevelopment1" "ssas-dev1" "ssas-dev2" "Y" -Verbose
.INPUTS
    The [Subscription] parameter is the name of the Azure subscription.

    The [AzureRegion] parameter is the name of the Azure Region/Location.

    The [AzureRGName] parameter is the name of the Azure Resource Group where the Tenant Manifest Table is stored.

    The [AzureSAName] parameter is the name of the Storage Account where the Tenant Manifest Table is stored.

    The [TableName] parameter is the name of Tenant Manifest Table to insert a new row for this tenant.

	The [KVName] parameter is the name of Key Vault to create and store the encypriton key used to encrypt the tenant specific data files ingested by the AppSuiteIngestionAPI[Environment].

    The [TenantName] parameter is the name of the display name for this Tenant.

    The [TenantDomain] parameter is the name of the FQDN of the Tenant.

    The [DBServer] parameter is the name of Azure Sql Database Server to create the Tenant specific databases.

    The [SSASServer1] parameter is the name of SSAS Primary VM.

    The [SSASServer2] parameter is the name of of the SSAS Secondary VM.

    The [Active] parameter is the value for whether the Tenant is Active (Y or N) (or disable due to billing issue).
.OUTPUTS
    Normal Verbose/Debug output included with -Verbose or -Debug parameters.
#>

#Requires -RunAsAdministrator
#Requires -Version 5.0

[CmdletBinding()]
Param(
    [Parameter(Mandatory=$True, Position=0, HelpMessage="The name of the Azure Subscription to which access has been granted.")]
    [string]$Subscription,
    [Parameter(Mandatory=$True, Position=1, HelpMessage="The name of destination Azure Region.")]
    [ValidatePattern({^[a-zA-Z0-9]})]
    [string]$AzureRegion,
    [Parameter(Mandatory=$True, Position=2, HelpMessage='The name of the Azure Resource Group to update.')]
    [string]$AzureRGName,
    [Parameter(Mandatory=$True, Position=3, HelpMessage='The Storage Account name in which the the Azure Table to exists.')]
    [string]$AzureSAName,
    [Parameter(Mandatory=$True, Position=4, HelpMessage='The Azure Table to work with.')]
    [string]$TableName,
	[Parameter(Mandatory=$True, Position=5, HelpMessage='The Azure Key Vault to store the Tenant Encryption Key.')]
    [string]$KVName,
    [Parameter(Mandatory=$True, Position=6, HelpMessage='The Steward AppSuite Tenant Name.')]
    [string]$TenantName,
    [Parameter(Mandatory=$True, Position=7, HelpMessage='The Steward AppSuite Tenant (FQDN) Domain Name.')]
    [string]$TenantDomain,
    [Parameter(Mandatory=$True, Position=8, HelpMessage='The desired Steward AppSuite Shared SQL Azure Database Server Name.')]
    [string]$DBServer,
    [Parameter(Mandatory=$True, Position=9, HelpMessage='The desired Primary Steward AppSuite Shared SSAS Server Name.')]
    [string]$SSASServer1,
    [Parameter(Mandatory=$True, Position=10, HelpMessage='The desired Secondary Steward AppSuite Shared SSAS Server Name.')]
    [string]$SSASServer2,
    [Parameter(Mandatory=$True, Position=11, HelpMessage='The Steward AppSuite Active Tenant Flag.')]
    [string]$Active
    )

#region Variables
<#

Sample variables for bypassing the script parameters for testing.

[string]$Subscription = "AppSuite"
[string]$AzureRegion = "East US 2"
[string]$AzureRGName = "Subscription_Common"
[string]$AzureSAName = "sassubcom1"
[string]$TableName = "TMStage"
[string]$KVName = "sasscs"

[string]$TenantName = "StewardHealthcare"
[string]$TenantDomain = "steward.org"
[string]$DBServer = "sasstage1"
[string]$SSASServer1 = "ssas-stg01"
[string]$SSASServer2 = "ssas-stg02"
[string]$Active = "Y"

[string]$TenantName = "BlueMetalHealthcare"
[string]$TenantDomain = "bluemetal.com"
[string]$DBServer = "sasdevelopment2"
[string]$SSASServer1 = "ssas-dev01"
[string]$SSASServer2 = "ssas-dev02"
[string]$Active = "Y"

[string]$TenantName = "CapeCodHospital"
[string]$TenantDomain = "capecod.org"
[string]$DBServer = "sasdevelopment2"
[string]$SSASServer1 = "ssas-dev01"
[string]$SSASServer2 = "ssas-dev02"
[string]$Active = "Y"

[string]$TenantName = "SouthShoreHospital"
[string]$TenantDomain = "southshore.org"
[string]$DBServer = "sasdevelopment2"
[string]$SSASServer1 = "ssas-dev01"
[string]$SSASServer2 = "ssas-dev02"
[string]$Active = "Y"

#>
#endregion Variables


#region Functions



#region CheckPowerShell()

Function CheckPowerShell()
{

    # Check if we're running in the PowerShell ISE or PowerShell Console.
    If ($Host.Name -like "*ISE*")
    {
        [bool]$ISE = $True
        # Console output with -Verbose only
        Write-Verbose -Message "[Information] Running in PowerShell ISE."
        Write-Verbose -Message ""

        # Get the executing PowerShell script name for inclusion in Write-Verbose messages.
        [string]$PSScriptName = $psISE.CurrentFile.DisplayName.Trim(".ps1*")
        
    }

    Else # Executing from the PowerShell Console instead of the PowerShell ISE.
    
    {
        [bool]$ISE = $False
        # Console output with -Verbose only
        Write-Verbose -Message "[Information] Running in PowerShell Console."
        Write-Verbose -Message ""

        # Get the executing PowerShell script name for inclusion in Write-Verbose messages.
        [string]$PSScriptName = Split-Path $MyInvocation.PSCommandPath -Leaf
        
    }

    Return [bool]$ISE, [string]$PSScriptName

} # End CheckPowerShell()

#endregion CheckPowerShell()



#region Login-AzureRMInteractive()

Function Login-AzureRMInteractive()
{
    Param ([String]$Subscription)

    Try
    {
        # Console output with -Verbose only
        Write-Verbose -Message "[Start] Login required to retrieve Azure AD user context."
        Write-Verbose -Message ""

        $AzureRMContext = Login-AzureRmAccount

        # Console output with -Verbose only
        Write-Verbose -Message "[Finish] Azure AD user context $($AzureRMContext.Context.Account.Id) retrieved."
        Write-Verbose -Message ""

    } # End Try

    Catch
    
    {
        # Console output with -Verbose only
        Write-Verbose -Message $Error[0].Exception.Message
        Write-Verbose -Message ""

	    Write-Verbose -Message "[Error] Attempt to get ARM Context for subscription: $Subscription failed."
        Write-Verbose -Message ""

	    # Console output with -Debug only
	    Write-Debug -Message $Error[0].Exception.Message
        Write-Debug -Message ""

	    # Clear $Error, if one occured
        $Error.Clear()

    } # End Catch

    Return $AzureRMContext

} # End Function Login-AzureRMInteractive()

#endregion Login-AzureRMInteractive()



#region Select-Subscription()

Function Select-Subscription()
{

    Param ([String]$Subscription)

    Try
    {
        # Ensure that $Error is clear before we begin
        $Error.Clear()

	    # Console output with -Verbose only
        Write-Verbose -Message "[Start] Attempting to select Azure subscription: $Subscription."
        Write-Verbose -Message ""

        # Select the Azure Subscription...
        $SubcriptionContext = Set-AzureRmContext -SubscriptionName $Subscription -ErrorAction Stop

        # Console output with -Verbose only
        Write-Verbose -Message "[Finish] Currently selected Azure subscription is: $Subscription."
        Write-Verbose -Message ""

        Return $SubcriptionContext

    } # End Try

    Catch
    
    {
        # Console output with -Verbose only
        Write-Verbose -Message $Error[0].Exception.Message
        Write-Verbose -Message ""

		Write-Verbose -Message "[Error:$PSScriptName] Attempt to select Azure subscription: $Subscription failed."
        Write-Verbose -Message ""

		# Console output with -Debug only
		Write-Debug -Message $Error[0].Exception.Message
        Write-Debug -Message ""

		# Clear $Error, if one occured
        $Error.Clear()

        # This is such a catastrophic error we have to abandon further execution.
        Exit

    } # End Catch

} # End Select-Subscription()


#endregion Select-Subscription()



#region Get-RandomCharacters

Function Get-RandomCharacters()
{
	param($Length = 3, $CharacterSet = 'abcdefghkmnprstuvwxyz')
	
    # Select 3 random characters from the set...
	$Random = 1..$Length | ForEach-Object { Get-Random -Maximum $CharacterSet.Length }
	
	# ...now, return the 3 characters selected and remove the spaces.
    $Private:OFS=""
	Return [String]$CharacterSet[$Random]

} # End Function Get-RandomCharacters()

#endregion Get-RandomCharacters



#region Add-Entity()

Function Add-Entity()
{
    [CmdletBinding()]
    param(
       $table,
       [string]$PartitionKey,
       [string]$RowKey,
       [string]$TenantName,
       [string]$TenantKey,
       [string]$StorageAccountRoot,
       [string]$DBServer,
       [string]$MDSdbName,
       [string]$RMdbName,
       [string]$DMdbName,
       [string]$SSASServer1,
       [string]$SSASServer2,
       [string]$CubeName,
       [string]$Active
    )

  $Entity = New-Object -TypeName Microsoft.WindowsAzure.Storage.Table.DynamicTableEntity -ArgumentList $PartitionKey, $RowKey
  $Entity.Properties.Add("Name", $TenantName)
  $Entity.Properties.Add("Key", $TenantKey)
  $Entity.Properties.Add("StorageAccountRoot", $StorageAccountRoot)
  $Entity.Properties.Add("MDSConnectionString", "server=tcp:" + $DBServer + ".database.windows.net,1433;database=" + $MDSdbName + ";user id={0};password={1};encrypt=true;trustservercertificate=false")
  $Entity.Properties.Add("RMConnectionString", "server=tcp:" + $DBServer + ".database.windows.net,1433;database=" + $RMdbName + ";user id={0};password={1};encrypt=true;trustservercertificate=false")
  $Entity.Properties.Add("DMConnectionString", "server=tcp:" + $DBServer + ".database.windows.net,1433;database=" + $DMdbName + ";user id={0};password={1};encrypt=true;trustservercertificate=false")
  $Entity.Properties.Add("TM1ConnectionString", "datasource=" + $SSASServer1 + ";catalog=" + $CubeName)
  $Entity.Properties.Add("TM2ConnectionString", "datasource=" + $SSASServer2 + ";catalog=" + $CubeName)
  $Entity.Properties.Add("Active", $Active)

  # Console output with -Verbose only
  Write-Verbose -Message "[Start] Attempting to add new tenant: $Tenantname."
  Write-Verbose -Message ""

  $Result = $Table.CloudTable.Execute([Microsoft.WindowsAzure.Storage.Table.TableOperation]::Insert($Entity))
  
  # Console output with -Verbose only
  Write-Verbose -Message "[Finish] Added new tenant: $Tenantname."
  Write-Verbose -Message ""


} # End Function Add-Entity()

#endregion Add-Entity()



#region Get-Entity()

Function Get-Entity()
{
    param([string]$TenantDomain)

    # Get table row
    $TableResult = $Table.CloudTable.Execute([Microsoft.WindowsAzure.Storage.Table.TableOperation]::Retrieve(“0”, $TenantDomain))
    $Entity = $TableResult.Result

    Return $Entity

} # End Function

#endregion Get-Entity()



#region Create-EncryptionKey

Function Create-EncryptionKey
{

    # Generates an AES256 Encryption Key to be used for the tenants file ingestion process.
    # This value is then stored in the Environment Key Vault for access by the IngestionAPI.

    $AESKey = New-Object System.Security.Cryptography.AesManaged
    $AESKey.KeySize = 256
    $AESKey.GenerateKey()
    $Key = [System.Convert]::ToBase64String($AESKey.Key)

    Return $Key

}

#endregion Create-EncryptionKey



#region Create-ResourceGroup()

Function Create-ResourceGroup
{
    Param([String]$Name, [String]$Region, [string]$Environment, [string]$Tenant, [string]$TenantKey)

	# Console output with -Verbose only
    Write-Verbose -Message "[Start] Attempting to create new Resource Group $Name."
    Write-Verbose -Message ""

    Try
    {
		# Ensure that $Error is clear before we begin
        $Error.Clear()

		# https://github.com/Azure/azure-powershell/issues/906
		# https://social.msdn.microsoft.com/Forums/en-US/cf5f7777-e5f2-4423-bdcd-db4b611e1be6/different-behavior-on-getazureresource-it-started-to-throw-resourcenotfound-exception-from-v091?forum=azurescripting
		# If (!(Test-AzureResourceGroup -ResourceGroupName $Name))
		#{
			# Azure Resource Group does not exist, so let's attempt to create it.
			$ResourceGroupName = New-AzureRMResourceGroup -Name $Name -Location $Region -Tag @{Name="Environment";Value=$Environment}, @{Name="Tenant";Value=$Tenant}, @{Name="TenantKey";Value=$TenantKey} -ErrorAction Stop -Force
	
		#}
		#Else
		#{
			# Azure Resource Group already exists, so lets just return it.
			# $ResourceGroupName = Get-AzureRMResourceGroup -Name $Name
		#}
    }
    Catch
    {
		# Console output with -Verbose only
        Write-Verbose -Message $Error[0].Exception.Message
        Write-Verbose -Message "[Error] Exiting due to exception: Resource Group not created."

		# Ensure that $Error is clear after we quit
        $Error.Clear()

    } # End Try/Catch

	# Console output with -Verbose only
    Write-Verbose -Message "[Finish] Created new Resource Group $Name."
    Write-Verbose -Message ""

	# Return $ResourceGroupName.ResourceGroupName
    Return $ResourceGroupName

} # End Function Create-ResourceGroup

#endregion Create-ResourceGroup()



#region Import-ServiceBusDLL()

Function Import-ServiceBussDLL
{
    # Depends upon CheckPowerShell() Function

    # Console output
    Write-Verbose -Message "[Start] Adding the [Microsoft.ServiceBus.dll] assembly to the script..."
    
    If ($ISE) # Executing from the PowerShell ISE instead of the PowerShell Console.
    {
        # If we're executing in the ISE, then we can use $PSISE to get the executing scripts file location.
        
        # WARNING: Make sure to reference the latest version of Microsoft.ServiceBus.dll and place it into the scripts \Packages folder!
        
        Try
        {

            # Get the current folder that the PowerShell script is executing from.
            $CurrentFolder = (Split-Path -Parent $psISE.CurrentFile.FullPath)
            # Move up one level since this should be being executed from GitHub
            $PackagesFolder = (Split-Path -Parent $CurrentFolder) + "\Packages"

            $Assembly = Get-ChildItem $PackagesFolder -Include "Microsoft.ServiceBus.dll" -Recurse
            Add-Type -Path $Assembly.FullName

        }

        Catch [System.Exception]
        {

            # Console output
            Write-Verbose -Message "Could not add the Microsoft.ServiceBus.dll assembly to the script."
            # Console output
            # $Exception = $error[0].Exception.GetType().FullName
            Throw "Microsoft Azure Service Bus DLL is required! [http://www.nuget.org/packages/WindowsAzure.ServiceBus] Aborting..."

        } # End Try / Catch

    } # End If
    Else # Executing from the PowerShell Console instead of the PowerShell ISE.
    {

        Try
        {

        # If we're executing in the Console, then we have to use $PSCommandPath to get the executing scripts file location.
        $PSScript = $PSCommandPath | Split-Path -Parent
        # Move up one level since this should be being executed from GitHub
        $PSScript = $PSScript | Split-Path -Parent
        $PackagesFolder = $PSScript + "\Packages"
        $Assembly = Get-ChildItem $PackagesFolder -Include "Microsoft.ServiceBus.dll" -Recurse
        Add-Type -Path $Assembly.FullName

        }

        Catch [System.Exception]
        {

            # Console output
            Write-Verbose -Message "Could not add the Microsoft.ServiceBus.dll assembly to the script."
            # Console output
            # $Exception = $error[0].Exception.GetType().FullName
            Throw "Microsoft Azure Service Bus DLL is required! [http://www.nuget.org/packages/WindowsAzure.ServiceBus] Aborting..."

        } # End Try / Catch
        
    } # End Else

    # Console output
    Write-Verbose -Message "[Finish] Added the [Microsoft.ServiceBus.dll] assembly to the script..."
        
} #End Function Import-ServiceBussDLL

#endregion Import-ServiceBusDLL()



#region Create-Queue

Function Create-Queue()
{
    Param  ($AzureSBNS, $QName, $AzureSBNameSpace)

    # Attempt to create a new Queue within this Azure Service Bus Namespace.
        
    <#

    In order to provision other Service Bus entities, we create an instance of the NamespaceManager object from the SDK.
    We can use the NamespaceManager to retrieve and provide a connection string.
    We'll store a reference to the NamespaceManager instance in the $NamespaceManager variable.

    #>

    $NamespaceManager = $null

    # Console output
    Write-Verbose -Message "[Start] Creating Azure Service Bus Namespace Manager $AzureSBNameSpace." -Verbose
    Write-Verbose -Message " " -Verbose

    Do # Azure has a delay sometimes in creating this object.
    {

        $NamespaceManager = [Microsoft.ServiceBus.NamespaceManager]::CreateFromConnectionString($AzureSBNS.ConnectionString)

    } While ($NamespaceManager -eq $null)

    # Console output
    Write-Verbose -Message "[Finish] Created Azure Service Bus Namespace Manager for $AzureSBNameSpace." -Verbose
    Write-Verbose -Message " " -Verbose

    If ($NamespaceManager.QueueExists($QName))
    {
        # Console output
        Write-Verbose -Message "[Information] Queue $QName in $AzureSBNameSpace already exists." -Verbose
        Write-Verbose -Message " " -Verbose

    }
    Else # Event Hub does not exist.
    {

        # Console output
        Write-Verbose -Message "[Start] Creating Queue $QName." -Verbose
        Write-Verbose -Message " " -Verbose

        Try
        {

            Do # Azure has a delay sometimes in creating this object.
            {

            $QContext = New-Object -TypeName Microsoft.ServiceBus.Messaging.QueueDescription -ArgumentList $QName
            Write-Verbose -Message "[Information] Trying to create context for Queue $QName." -Verbose

            } While ($QContext -eq $null)

            $TimeToLive = New-TimeSpan -Days 14
            $QContext.DefaultMessageTimeToLive = $TimeToLive
            $QContext.EnablePartitioning = $False
                        
            $Queue = $NamespaceManager.CreateQueue($QContext)

            # Console output
            Write-Verbose -Message "[Finish] Created Queue $QName." -Verbose
            Write-Verbose -Message " " -Verbose

            # Console output
            Write-Verbose -Message "[Start] Creating Queue $QName Shared Access Policies." -Verbose
            Write-Verbose -Message " " -Verbose

            # NOTE:  At the present time, Microsoft New-AzureSBAuthorizationRule cmdlet is broken! Therefore these rules need to be created in the
            #        Azure Management Console manually.

            Do # Azure has a delay sometimes in creating this object.
            {
                Start-Sleep -Seconds 15
                $ManageRule = New-AzureSBAuthorizationRule -Name "Manage" -Namespace $AzureSBNameSpace -Permission $("Manage", "Listen", "Send") -EntityName $QName -EntityType Queue -ErrorAction SilentlyContinue
            } While ($ManageRule -eq $null)

            # Console output
            Write-Verbose -Message "[Information] Created Queue $QName Shared Access Policy:  Manage" -Verbose
            Write-Verbose -Message " " -Verbose
            Write-Verbose -Message $ManageRule.ConnectionString -Verbose

            Do # Azure has a delay sometimes in creating this object.
            {
                Start-Sleep -Seconds 15
                $ListenRule = New-AzureSBAuthorizationRule -Name "Listen" -Namespace $AzureSBNameSpace -Permission $("Listen") -EntityName $QName -EntityType Queue -ErrorAction SilentlyContinue
            } While ($ListenRule -eq $null)

            # Console output
            Write-Verbose -Message "[Information] Created Queue $QName Shared Access Policy:  Listen" -Verbose
            Write-Verbose -Message " " -Verbose
            Write-Verbose -Message $ListenRule.ConnectionString -Verbose

            Do # Azure has a delay sometimes in creating this object.
            {
                Start-Sleep -Seconds 15
                $SendRule = New-AzureSBAuthorizationRule -Name "Send" -Namespace $AzureSBNameSpace -Permission $("Send") -EntityName $QName -EntityType Queue -ErrorAction SilentlyContinue
            } While ($SendRule -eq $null)

            # Console output
            Write-Verbose -Message "[Information] Created Queue $QName Shared Access Policy:  Send" -Verbose
            Write-Verbose -Message " " -Verbose
            Write-Verbose -Message $SendRule.ConnectionString -Verbose

            # Console output
            Write-Verbose -Message "[Finish] Created Queue $QName Shared Access Policies." -Verbose
            Write-Verbose -Message " " -Verbose
        }
        Catch
        {

            # Console output
            Write-Verbose -Message $Error[0].Exception.Message -Verbose
            Write-Verbose -Message " " -Verbose

        } # End Try / Catch

    } # End If


} # End Function Create-Queue

#endregion Create-Queue



#endregion Functions



#region Main

# Mark the start time.
$StartTime = Get-Date
Write-Verbose -Message "Start Time ($($StartTime.ToLocalTime()))."

# What version of Microsoft Azure PowerShell are we running?
# Console output with -Debug only
Write-Debug -Message (Get-Module azure -ListAvailable).Version
Write-Debug -Message ""

Clear-Host

# Provide credentials to sign into Azure and retrieve authorized subscriptions.
$LoginContext = Login-AzureRMInteractive -Subscription $Subscription

# Set default values for PowerShell script...
[string]$PSScriptName = $null
$SubscriptionContext = $null

# Call Function
$Return = CheckPowerShell
$ISE = $Return[0]
$PSScriptName = $Return[1]

# Console output with -Verbose only
Write-Verbose -Message $ISE
Write-Verbose -Message $PSScriptName.Trim(".ps1*")
Write-Verbose -Message ""

# Call Function
$SubscriptionContext = Select-Subscription -Subscription $Subscription

If ($SubscriptionContext -ne $null)

{
    # Check to see if our $Subscription was found and selected.
    Get-AzureRmContext

    # Console output with -Verbose only
    Write-Verbose -Message $SubscriptionContext.Subscription.SubscriptionName
    Write-Verbose -Message ""

}

#Call Function
Import-ServiceBussDLL

# Select the storage account and context where the Tenant Manifest table is to reside.
$KeyTM = (Get-AzureRmStorageAccountKey -Name $AzureSAName -ResourceGroupName $AzureRGName)[0]
$SaCTM = New-AzureStorageContext -StorageAccountName $AzureSAName -StorageAccountKey $KeyTM.Value

# Console output with -Verbose only
Write-Verbose -Message "[Start] Attempting to retrieve Tenant Manifest table $TableName."
Write-Verbose -Message ""

# Retrieve the table if it already exists.
$Table = Get-AzureStorageTable –Name $TableName -Context $SaCTM -ErrorAction Stop

# If we don't already have a $TenantDomain row in our $TableName, then we will proceed to Add-Entity, otherwise we fail.
If ($Table -ne $null)
{

    # Console output with -Verbose only
    Write-Verbose -Message "[Finish] Retrieved Tenant Manifest table $TableName."
    Write-Verbose -Message ""

    # Console output with -Verbose only
    Write-Verbose -Message "[Start] Attempting to retrieve Tenant $TenantDomain Tenant Manifest $TableName."
    Write-Verbose -Message ""


    # Check to see if we have a $TenantDomain row in our Table as that's our RowKey.
    $Entity = Get-Entity -TenantDomain $TenantDomain

    # If we don't already have a $TenantDomain row in our $TableName, then we will proceed to Add-Entity, otherwise we fail.
    If ($Entity -eq $null)
    {

        # Console output with -Verbose only
        Write-Verbose -Message "[Finish] Tenant $TenantDomain in Tenant Manifest $TableName does not exist. Adding..."
        Write-Verbose -Message ""


        #region Create unique tenant key
        
            # Get only the first three characters of the TenantName to construct unique TenantKey.
            [int]$Char3 = $TenantName.Length-3
            $TenantShortName = $TenantName.Substring(0,($TenantName.Length-$Char3)).ToLower()

            # Call Function to get 3 random lowercase characters to construct unique TenantKey.
            $Characters = Get-RandomCharacters

            # Generate random number between 0-99 to construct unique TenantKey.
            $Number = Get-Random -Maximum 100

        #endregion Create unique tenant key

        # Check to see if this TenantKey Storage Account already exists.
        $CheckSA = Get-AzureRmStorageAccountNameAvailability -Name $($TenantShortName+$Characters+$Number)

        # Since ALL of the Tenant Manifest dabases are name TM(Environemnt) we will trim off the TM to figure out into which Environment we need to place this tenant.
        $AzureRGEnvironmentName = $TableName.Replace("TM","")

        # Call Function
        $ResourceGroupName = Create-ResourceGroup -Name $($AzureRGEnvironmentName + "_" + $TenantName) -Region $AzureRegion -Environment $AzureRGEnvironmentName -Tenant $TenantName -TenantKey $($TenantShortName+$Characters+$Number)
        
        If ($CheckSA.NameAvailable)
        {

            # Console output with -Verbose only
            Write-Verbose -Message "[Start] Attempting to create Storage Account 'https://$($TenantShortName+$Characters+$Number).blob.core.windows.net/'."
            Write-Verbose -Message ""

            # Create the Storage Account
            $SA = New-AzureRmStorageAccount -ResourceGroupName $ResourceGroupName.ResourceGroupName -AccountName $($TenantShortName+$Characters+$Number) -Location $AzureRegion -Type "Standard_GRS" -Tags @{Name="Environment";Value=$AzureRGEnvironmentName}, @{Name="Tenant";Value=$TenantName}, @{Name="TenantKey";Value=$($TenantShortName+$Characters+$Number)}
            Set-AzureStorageServiceMetricsProperty -Context $SA.Context -ServiceType Blob -MetricsType Hour -MetricsLevel ServiceAndApi -RetentionDays 30
            Set-AzureStorageServiceLoggingProperty -Context $SA.Context -ServiceType Blob -LoggingOperations All -RetentionDays 30
            
            # Console output with -Verbose only
            Write-Verbose -Message "[Finish] Created Storage Account 'https://$($TenantShortName+$Characters+$Number).blob.core.windows.net/'."
            Write-Verbose -Message ""

            # Console output with -Verbose only
			Write-Verbose -Message ""
			Write-Verbose -Message "[Start] Adding Storage Account Key1 secret [$("IngestionStorageAccountKey-"+$TenantShortName+$Characters+$Number)] to Key Vault [$KVName]."
			Write-Verbose -Message ""

            # Get the Storage Account Key1 to store in Key Vault.
            $Key = (Get-AzureRmStorageAccountKey -Name $($TenantShortName+$Characters+$Number) -ResourceGroupName $ResourceGroupName.ResourceGroupName)[0]
            
            # Set the Storage Account Key1 as a secret in the vault
            $SecretValue = ConvertTo-SecureString -String $Key.Value -AsPlainText -Force
            Set-AzureKeyVaultSecret -VaultName $KVName -Name $("IngestionStorageAccountKey-"+$TenantShortName+$Characters+$Number) -SecretValue $SecretValue

            # Console output with -Verbose only
			Write-Verbose -Message ""
			Write-Verbose -Message "[Finish] Adding Storage Account Key1 secret [$("IngestionStorageAccountKey-"+$TenantShortName+$Characters+$Number)] to Key Vault [$KVName]."
			Write-Verbose -Message ""
            
            # Create Storage Account Containers
            # Microsoft has not released an update to the New-AzureStorageContainer cmdlet which should be New-AzureRmStorageContainer, so we'll use
            # the old Classic mode one which appears to work at this time.
            
            # Not needed,but kept here for future reference:
            # $Key = (Get-AzureRmStorageAccountKey -Name $SA.StorageAccountName -ResourceGroupName $ResourceGroupName.ResourceGroupName).Key1
            # $SaC = New-AzureStorageContext -StorageAccountName $SA.StorageAccountName -StorageAccountKey $Key

            # Console output with -Verbose only
            Write-Verbose -Message "[Start] Attempting to create Storage Account Containers (/drop, archive, /error) in 'https://$($TenantShortName+$Characters+$Number).blob.core.windows.net/'."
            Write-Verbose -Message ""

            New-AzureStorageContainer -Name "drop" -Context $SA.Context -Permission Off
            New-AzureStorageContainer -Name "archive" -Context $SA.Context -Permission Off
            New-AzureStorageContainer -Name "error" -Context $SA.Context -Permission Off

            # Console output with -Verbose only
            Write-Verbose -Message "[Finish] Created Storage Account Containers (/drop, archive, /error) in 'https://$($TenantShortName+$Characters+$Number).blob.core.windows.net/'."
            Write-Verbose -Message ""

            # Console output with -Verbose only
            Write-Verbose -Message "[Start] Attempting to retrieve SQL Server $DBServer."
            Write-Verbose -Message ""

            # Get the DBServer specified on the command line
            $SQLServer = Get-AzureRmSqlServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -ServerName $DBServer -ErrorAction SilentlyContinue

            If ($SQLServer -ne $null)
            {

                # Console output with -Verbose only
                Write-Verbose -Message "[Finish] Retrieved SQL Server $DBServer."
                Write-Verbose -Message ""

                # Microsoft, in their infinite wisdom screwed up the Tags for SQL which will not accept a Hashtable.
                $Dictionary = New-Object 'System.Collections.Generic.Dictionary`2[System.String,System.String]'
                $Dictionary.Add("Environment",$AzureRGEnvironmentName)
                $Dictionary.Add("Tenant",$TenantName)
                $Dictionary.Add("TenantKey",$($TenantShortName+$Characters+$Number))
                
                # Console output with -Verbose only
                Write-Verbose -Message "[Start] Creating databases on $DBServer."
                Write-Verbose -Message ""

                $MDSdb = New-AzureRmSqlDatabase -ServerName $DBServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"MDS") -Edition Standard -RequestedServiceObjectiveName "S0" -Tags $Dictionary
                # When Microsoft fixes the tagging issues...
                # -Tags @{Name="Environment";Value=$AzureRGEnvironmentName}, @{Name="Tenant";Value=$TenantName}, @{Name="TenantKey";Value=$($TenantShortName+$Characters+$Number)}
                
                # Set TDE Enabled
                Set-AzureRmSqlDatabaseTransparentDataEncryption -ServerName $DBServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"MDS") -State Enabled

                # Set Audit Policy
                Set-AzureRmSqlDatabaseAuditingPolicy -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -ServerName $DBServer -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"MDS") -StorageAccountName "sassubcom2" -RetentionInDays 30 -TableIdentifier "$($TenantShortName+$Characters+$Number)MDS"
                
                $RMdb = New-AzureRmSqlDatabase -ServerName $DBServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"RM") -Edition Standard -RequestedServiceObjectiveName "S0" -Tags $Dictionary
                # When Microsoft fixes the tagging issues...
                # -Tags @{Name="Environment";Value=$AzureRGEnvironmentName}, @{Name="Tenant";Value=$TenantName}, @{Name="TenantKey";Value=$($TenantShortName+$Characters+$Number)}

                # Set TDE Enabled
                Set-AzureRmSqlDatabaseTransparentDataEncryption -ServerName $DBServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"RM") -State Enabled
                
                # Set Audit Policy
                Set-AzureRmSqlDatabaseAuditingPolicy -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -ServerName $DBServer -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"RM") -StorageAccountName "sassubcom2" -TableIdentifier "$($TenantShortName+$Characters+$Number)RM"

                $DMdb = New-AzureRmSqlDatabase -ServerName $DBServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"DM") -Edition Standard -RequestedServiceObjectiveName "S0" -Tags $Dictionary
                # When Microsoft fixes the tagging issues...
                # -Tags @{Name="Environment";Value=$AzureRGEnvironmentName}, @{Name="Tenant";Value=$TenantName}, @{Name="TenantKey";Value=$($TenantShortName+$Characters+$Number)}
                
                # Set TDE Enabled
                Set-AzureRmSqlDatabaseTransparentDataEncryption -ServerName $DBServer -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"DM") -State Enabled

                # Set Audit Policy
                Set-AzureRmSqlDatabaseAuditingPolicy -ResourceGroupName $($AzureRGEnvironmentName + "_Common") -ServerName $DBServer -DatabaseName ($($TenantShortName+$Characters+$Number)+ "_" +"DM") -StorageAccountName "sassubcom2" -TableIdentifier "$($TenantShortName+$Characters+$Number)DM"
                
                # Console output with -Verbose only
                Write-Verbose -Message "[Finish] Created databases on $DBServer."
                Write-Verbose -Message ""

            }
            Else
            {
                # Console output with -Verbose only
                Write-Verbose -Message "[Error] SQL Database Server $DBServer does not exist!."
                Write-Verbose -Message ""

                # This is such a catastrophic error we have to abandon further execution.
                Exit

            }
            
			# Console output with -Verbose only
			Write-Verbose -Message ""
			Write-Verbose -Message "[Start] Adding file encryption secret [$("IngestionEncryptionKey-"+$TenantShortName+$Characters+$Number)] to Key Vault [$KVName]."
			Write-Verbose -Message ""

			# Add a Key for encrypting this tenants files by the AppSuiteIngestionAPI[Environment].
			# Add-AzureKeyVaultKey -VaultName $KVName -Name $($TenantShortName+$Characters+$Number) -Destination Software

            $SecretValue = Create-EncryptionKey
            $SecretValue = ConvertTo-SecureString -String $SecretValue -AsPlainText -Force
            # Set the password as a secret in the vault
            Set-AzureKeyVaultSecret -VaultName $KVName -Name $("IngestionEncryptionKey-"+$TenantShortName+$Characters+$Number) -SecretValue $SecretValue

			# Console output with -Verbose only
			Write-Verbose -Message ""
			Write-Verbose -Message "[Finish] Adding file encryption secret [$("IngestionEncryptionKey-"+$TenantShortName+$Characters+$Number)] to Key Vault [$KVName]."
			Write-Verbose -Message ""

            # Check to see if we have an Azure Service Bus Namespace by that name.
            # Since our naming standards got off the rails a bit we need to shorten them to match the App Services / APIs/WebApps.
            $AzureSBNameSpace = $null
            Switch ($AzureRGEnvironmentName)
            {

                Development {$AzureSBNameSpace = "sassbdcm"}
                Test {$AzureSBNameSpace = "sassbtcm"}
                Stage {$AzureSBNameSpace = "sassbscm"}
                Production {$AzureSBNameSpace = "sassbpcm"}

            }
            
            $AzureSBNS = Get-AzureSBNamespace -Name "sassbdcm"

            Get-AzureSBNamespace "sassbdcm"
            


            # Add tenant to tenant manifest table.
            Add-Entity -Table $Table -PartitionKey 0 -RowKey $TenantDomain -TenantName $TenantName -TenantKey $($TenantShortName+$Characters+$Number)`
             -StorageAccountRoot "https://$($TenantShortName+$Characters+$Number).blob.core.windows.net/" -DBServer $DBServer -MDSdbName $MDSdb.DatabaseName -RMdbName $RMdb.DatabaseName -DMdbName $DMdb.DatabaseName -SSASServer1 $SSASServer1 -SSASServer2 $SSASServer2 -CubeName ($($TenantShortName+$Characters+$Number) + "_" + "TM") -Active $Active

        } # End If ($CheckSA)
        Else
        {

            <#

                To Do:  We should probably regenerate the Tenant Key and try again.

            #>

        }

        # Create a table query.
        $Query = New-Object Microsoft.WindowsAzure.Storage.Table.TableQuery

        $List = New-Object System.Collections.Generic.List[string]
        $List.Add("RowKey")
        $List.Add("Name")
        $List.Add("Key")
        $List.Add("StorageAccountRoot")
        $List.Add("MDSConnectionString")
        $List.Add("RMConnectionString")
        $List.Add("DMConnectionString")
        $List.Add("TM1ConnectionString")
        $List.Add("TM2ConnectionString")
        $List.Add("Active")

        $Query.FilterString = "RowKey eq '$($TenantDomain)'"
        $Query.SelectColumns = $List

        # Execute the query.
        $Entities = $Table.CloudTable.ExecuteQuery($Query)

        # Display entity properties with the table format.
        $Entities | Format-Table @{Expression={$_.Properties["Name"].StringValue};Label="TenantName";Width=10},`
            @{Expression={$_.RowKey};Label="Tenant Domain";Width=13},`
            @{Expression={$_.Properties[“Key”].StringValue};Label="Tenant Key";Width=8},`
            @{Expression={$_.Properties["StorageAccountRoot"].StringValue};Label="Storage Account";Width=15},`
            @{Expression={$_.Properties["MDSConnectionString"].StringValue};Label="MDSConnectionString";Width=30},`
            @{Expression={$_.Properties["RMConnectionString"].StringValue};Label="RMConnectionString";Width=30},`
            @{Expression={$_.Properties["DMConnectionString"].StringValue};Label="DMConnectionString";Width=30},`
            @{Expression={$_.Properties["TM1ConnectionString"].StringValue};Label="TM1ConnectionString";Width=30},`
            @{Expression={$_.Properties["TM2ConnectionString"].StringValue};Label="TM2ConnectionString";Width=30},`
            @{Expression={$_.Properties["Active"].StringValue};Label="Active?";Width=7}`
            -Wrap

    } # End If ($Entity -eq $null)
    Else
    {
        # Console output with -Verbose only
        Write-Verbose -Message ""
        Write-Verbose -Message "[Error] Tenant: $TenantDomain already exists!"
        Write-Verbose -Message ""

    } # End Else ($Entity -eq $null)

} # End If ($Table -ne $null)
Else
{

    # Console output with -Verbose only
    Write-Verbose -Message ""
    Write-Verbose -Message "[Warning] Tenant Manifest [$TableName] Table not found!"
    Write-Verbose -Message ""

} # End Else ($Table -ne $null)




# Mark the finish time.
$FinishTime = Get-Date
Write-Verbose -Message "Finish Time ($($FinishTime.ToLocalTime()))."

# Console output with -Verbose only
$TotalTime = ($FinishTime - $StartTime).Minutes
Write-Verbose -Message "Elapse Time (Minutes): $TotalTime"
Write-Verbose -Message ""


#endregion Main